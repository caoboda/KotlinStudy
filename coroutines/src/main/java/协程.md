## 协程

### 1、协程是什么

 协程基于线程，它是轻量级的线程。它可以让异步逻辑同步化，杜绝地狱回调。协程最核心的一点就是，函数或者一段程序能够被挂起，稍后再在被挂起的位置恢复。

### 2、在Android中协程用来解决什么问题

1.处理耗时任务，这种任务通常会阻塞主线程。
2.保证主线程安全，保证安全的从主线程调用任何的suspend函数。

### 3、协程的挂起与恢复

我们知道常规的函数操作包括：invoke(或call)和return，协程新增了suspend和resume：

suspend，也被称为挂起或者暂停，用于暂停执行当前协程，并保存所有局部变量。
resume,用于让已暂停的协程从其暂停处继续执行。

### 3、挂起函数

使用suspend关键字修饰的函数叫挂起函数。
挂起函数只能在携程体内或者其他挂起函数中调用。

### 4、挂起和阻塞的区别

挂起：执行挂起函数后，会回到挂起点，不会阻塞主线程，如我们点击一个按钮执行delay挂起函数，按钮会立马弹起来。
阻塞：执行阻塞函数后，会阻塞主线程，如我们点击一个按钮执行sleep函数，按钮直到sleep执行完后才弹起来。

### 5、协程实现的两个层次

基础设施层标准：标准库的协程API，主要对协程提供了概念和语义上的最基本的支持。
业务框架层：协程的上层框架支持。

### 6、协程调度器

所有的协程必须在调度器中运行，即使它们在主线程上运行也是如此。

调度器有Dispatchers.Main、Dispatchers.IO、Dispatchers.Default

Dispatchers.Main： Android上的主线程用来处理UI交互和一些轻量级任务，如调用suspend函数、调用UI函数、更新LiveData等。
Dispatchers.IO：非主线程，专为磁盘和网络IO进行了优化，如数据库、文件读写、网络处理等。
Dispatchers.Default：非主线程，专为CPU密集型任务进行了优化，如数组排序、JSON数据解析、处理差异判断等。

### 7、协程任务泄露

当某个协程任务丢失，无法追踪，会导致内存、CPU、磁盘等资源浪费，甚至发送一个无用的网络请求，这种情况称为任务泄露，跟内存泄露类似。为了能够避免协程任务泄露，kotlin引入了结构化并发机制。

使用结构化并发机制可以做到：
取消任务:当某项任务不再需要时取消它。
追踪任务：当任务正在执行时，追踪它。
发出错误信号：当协程失败时，发送错误信号表明有错误发生。

### 8、CoroutineScope（协程作用域）

定义协程必须指定其CoroutineScope，它会跟踪所有协程，同样它还可以取消由他启动的所有协程。
Android中常用的API有：
GlobalScope：生命周期是process进程级别的，即使Activity或者Fragment已经被销毁，协程仍在执行。
MainScope：在Activity中使用，可以在onDestroy()中使用。
viewModelScope：只能在viewModel中使用，绑定viewModel的生命周期。
lifecycleScope：只能在Activity、Fragment中使用，会绑定Activity或者Fragment的生命周期。

### 9、协程构建器

launch和async构建器都用来启动协程.
launch:返回一个Job并且不附带任何结果值。
async：返回一个Deferred，Deferred也是一个Job，可以使用.await()在一个延期的值上得到它的最终结果

### 10、协程的启动模式

CoroutineStart.DEFAULT：协程创建后，立即开始调度，在调度前如果协程被取消，其将直接进去取消响应的状态(Job取消会先进入取消响应的状态，然后再取消)。
CoroutineStart.ATOMIC：协程创建后，立即开始调度，协程执行到第一个挂起点之前不响应取消。
CoroutineStart.LAZY：只有协程被需要时，包括主动调用协程的start、join、或await等函数时才会开始调度，如果调度前就被取消，那么该协程将进入异常结束状态。
CoroutineStart.UNDISPATCHED：协程创建后立即在当前函数调用栈中执行，直到遇到第一个真正挂起的点。

### 11、协程的作用域构建器

#### runBlocking与coroutineScope

* runBlocking是常规函数，而coroutineScope是挂起函数
* 它们都会等待期协程体以及所有子协程结束，主要区别在于runBlocking会阻塞当前线程来等待,而coroutineScope只是挂起，会释放底层线程用于其他用途。

coroutineScope：一个协程失败了，所有其他兄弟协程也会被取消。
supervisorScope：一个协程失败了，不会影响其他兄弟协程。

### 12、Job对象

对于每一个创建的协程（通过launch或者async），会返回一个Job实例，这个实例是协程的唯一标识，并且负责管理协程的生命周期。
一个任务可以包含一系列的状态：新创建（New）、活跃（Active）、完成中（Completing）、已完成（Completed）、取消中（Cancelling）和已取消（cancelled）。虽然我们无法直接访问这些状态，但是我们可以访问Job的属性：isActive、isCancelled、isCompleted。

#### Job的生命周期

如果协程处于活跃的状态，协程运行出错时或者调用job.cancel()都会将当前任务置为取消中（Cancellinng）状态（isActivity = false，isCancelled = true）。当所有的子协程都完成后，协程会进入已取消（Cancelled）状态，此时isCompleted = true。

### 13、协程的取消

1、取消作用域会取消它的子协程。
2、被取消的子协程并不会影响其余的兄弟协程。
3、协程通过抛出一个特殊的异常CancellationException来处理取消操作。
4、所有kotlinx.coroutines中的挂起函数（withContext、delay等）都是可以取消的。

#### CPU密集型任务取消

isActive是一个可以被使用在CoroutineScope中的扩展属性，检查Job是否处于活跃状态。
ensureActive（），如果Job处于非活跃状态，这个方法会立即抛出异常。
yield函数会检查所在的协程的状态，如果已经取消，则抛出CancellationException予以响应。此外，它还会尝试让出线程的执行权，给其他协程提供执行的机会。

#### 不能取消的任务

处于取消状态中的协程不能够挂起（运行不能取消的代码），当协程被取消后需要调用挂起函数，我们需要将清理任务的代码放置于NonCancellable CoroutineContext中。这样挂起运行中的代码，并保持协程的取消中状态直到任务处理完成。

### 14、协程的超时任务

很多情况下取消一个协程的理由是它可能超时
withTimeoutOrNull通过返回null来进行超时操作，从而替代抛出一个异常。

### 15、协程的上下文

CoroutineContext是一组用于定义协程行为的元素，他由如下几项构成：
1、Job：控制协程的生命周期。
2、CoroutineDispatcher：向合适的线程分发任务。
3、CoroutineName：协程的名称，调试的时候用到。
4、CoroutineExceptionHandler：处理未被捕捉的异常。

#### 组合协程上下文

//有时候我们需要在协程的上下文中定义多个元素。我们可以使用+操作符来实现。如，我们可以显示的指定一个调度器来启动协程并且同时显示指定一个名称。

#### 组合协程上下文继承

对于新创建的协程，他的CoroutineContext会包含一个全新的Job实例，它会帮助我们控制协程的生命周期。而剩下的元素会从CoroutineContext的父类继承，该父类可能是另外一个协程或者创建该协程的CoroutineScope

#### 协程上下文继承公式

协程的上下文=默认值+继承的CoroutineContext+参数
1、一些元素包含默认值：Dispatchers.Default是默认的CoroutineDispatcher，以及“coroutine”作为默认的CoroutineName；
2、继承的CoroutineContext是CoroutineScope或者父协程的CoroutineContext；
3、传入协程构建器的参数优先级高于继承的上下文参数，因此会覆盖对应的参数值。

### 16、协程的异常

#### 根协程异常

协程的构建器有两种形式：自动传播异常(launch和actor)，像用户暴露异常（async与produce）当这些构建器用于创建一个根协程时（该协程不是另一个协程的子协程），前者这类构建器，异常会在它发生的第一时间被抛出，而后者则依赖用户最终来消费异常，如通过await或receive。

#### 非根协程异常

其他协程所创建的协程中，产生的异常总是会被传播。

#### 异常的传播特性

当一个协程由于一个异常而运行失败时，他会传播这个异常并传递给他的父级。接下来父级会进行下面几步操作：
1、取消它自己的子级。
2、取消它自己。
3、将异常传播并传递给它的父级。

#### SupervisorJob

 一个协程运行失败（异常）了不会影响其他子协程,它不会传播异常给它的父级，它会让子协程自己处理异常。即SupervisorJob（）可以取异常的传播特性。

#### SupervisorScope

当作业自身执行失败的时候，所有的子作业将会被全部取消

### 异常的捕获

使用CoroutineExceptionHandler对协程的异常进行捕获。
以下的条件被满足时，异常就会被捕获：
1、时机：异常是被自动抛出异常的协程所抛出的(使用launch而不是async)
2、位置：在CoroutineScope的CoroutineContext中或在一个根协程（CoroutineScope或者SupperVisorScope的直接子协程）中。

#### Android中全局异常处理

全局异常处理器可以获取到所有协程未处理的未捕获的异常，不过它并不能对异常进行捕获，虽然不能阻止程序崩溃，全局异常处理器在程序调试的异常上报等场景中仍然有非常大的用处。
我们需要在classpath下面创建META-INF/services目录，并在其中创建一个kotlinx.coroutines.CoroutineExceptionHandler的文件，文件内容就是我们的全局异常处理器的全类名。

#### 取消与处理

1、取消与异常紧密相关，协程内部使用CancellationException来进行取消，这个异常会被忽略。
2、当子协程被取消时，不会取消它的父协程。
3、如果一个协程遇到了CancellationException以外的异常，它将使用该异常取消它的父协程，当父协程的所有子协程都结束后，异常才会被父协程处理。

### 异常聚合

当协程的多个子协程因为异常而失败时，一般情况下取第一个异常进行处理，在第一个异常之后发生的其他所有异常，都将被绑定到第一个异常之上。















